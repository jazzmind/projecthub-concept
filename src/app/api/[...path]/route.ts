import { NextRequest } from 'next/server';
import { API } from '@/lib/server';
import { AuthBridge } from '@/lib/auth-bridge';

export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const path = url.pathname;
    const searchParams = Object.fromEntries(url.searchParams.entries());
    const isAuthEndpoint = path.startsWith('/api/auth/');
 
    const requestHeaders = Object.fromEntries(request.headers.entries());
    console.log('Route Request Headers', requestHeaders);

    // Always enrich headers with session data (no-op if not authenticated)
    const enrichedHeaders = await AuthBridge.enrichRequestHeaders(request);
    console.log('Enriched Headers:', enrichedHeaders);
    
    // Add any additional headers for auth endpoints
    if (isAuthEndpoint) {
      // Auth endpoints might need additional context from query params
      // This is handled by the enrichRequestHeaders already
    }
    
    console.log('Calling API.request with:', {
      method: 'GET',
      path,
      query: searchParams,
      headers: enrichedHeaders
    });
    
    const result = await API.request({ 
      method: 'GET', 
      path: path,
      query: searchParams,
      headers: enrichedHeaders
    });
    
    console.log('API.request result:', result);
    console.log('Waiting for response...');
    
    if ('error' in result) {
      const errorResponse = Response.json({ error: result.error }, { status: 500 });
      return AuthBridge.transformResponse(request, errorResponse, isAuthEndpoint);
    }
    
    // Wait in-memory for the engine response with a short timeout
    const raced = (await API._waitForResponse({ request: result.request, timeoutMs: 5000 })) as any[];
    if (!Array.isArray(raced) || raced.length === 0) {
      // No response generated by any sync; return empty array instead of 204
      console.log('[DEBUG] No response received, returning empty array');
      const empty = Response.json({ organizations: [] }, { status: 200 });
      return AuthBridge.transformResponse(request, empty, isAuthEndpoint);
    }

    const responseData = raced[0];
    
    // Type assertion since responseData structure is dynamic
    const apiResponse = responseData as any;
    const successResponse = Response.json(apiResponse.body || apiResponse, { status: apiResponse.statusCode || apiResponse.status || 200 });
    return AuthBridge.transformResponse(request, successResponse, isAuthEndpoint);
  } catch (error) {
    console.error('API GET Error:', error);
    const errorResponse = Response.json({ error: 'Internal server error' }, { status: 500 });
    return AuthBridge.transformResponse(request, errorResponse, false);
  }
}

export async function POST(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const path = url.pathname;
    const body = await request.json();
    const isAuthEndpoint = path.startsWith('/api/auth/');
    
    // Always enrich headers with session data (no-op if not authenticated)
    let headers = await AuthBridge.enrichRequestHeaders(request);
    
    // For auth endpoints, include body data in headers for sync processing
    if (isAuthEndpoint) {
      if (body.contextId) headers['x-context-id'] = body.contextId;
      if (body.resource) headers['x-resource'] = body.resource;
      if (body.action) headers['x-action'] = body.action;
      if (body.roles) headers['x-roles'] = JSON.stringify(body.roles);
    }
    
    const result = await API.request({
      method: 'POST',
      path: path,
      body: body,
      headers: headers
    });
    
    if ('error' in result) {
      const errorResponse = Response.json({ error: result.error }, { status: 500 });
      return AuthBridge.transformResponse(request, errorResponse, isAuthEndpoint);
    }
    
    // Wait in-memory for the engine response with a short timeout
    const raced = (await API._waitForResponse({ request: result.request, timeoutMs: 5000 })) as any[];
    if (!Array.isArray(raced) || raced.length === 0) {
      const empty = new Response(null, { status: 204 });
      return AuthBridge.transformResponse(request, empty, isAuthEndpoint);
    }

    const responseData = raced[0] as any;
    const successResponse = Response.json(responseData.body || responseData, { status: responseData.statusCode || responseData.status || 200 });
    return AuthBridge.transformResponse(request, successResponse, isAuthEndpoint);
  } catch (error) {
    console.error('API POST Error:', error);
    const errorResponse = Response.json({ error: 'Internal server error' }, { status: 500 });
    return AuthBridge.transformResponse(request, errorResponse, false);
  }
}

export async function PUT(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const path = url.pathname;
    const body = await request.json();
    const isAuthEndpoint = path.startsWith('/api/auth/');
    
    // Always enrich headers with session data
    const headers = await AuthBridge.enrichRequestHeaders(request);
    
    const result = await API.request({
      method: 'PUT',
      path: path,
      body: body,
      headers: headers
    });
    
    if ('error' in result) {
      const errorResponse = Response.json({ error: result.error }, { status: 500 });
      return AuthBridge.transformResponse(request, errorResponse, isAuthEndpoint);
    }
    
    const response = await API._waitForResponse({ request: result.request });
    const responseData = response.length > 0 ? response[0] : { error: 'No response received' };
    
    if ('error' in responseData) {
      const errorResponse = Response.json(responseData, { status: 500 });
      return AuthBridge.transformResponse(request, errorResponse, isAuthEndpoint);
    }
    
    // Type assertion since responseData structure is dynamic
    const apiResponse = responseData as any;
    const successResponse = Response.json(apiResponse.body || apiResponse, { status: apiResponse.status || 200 });
    return AuthBridge.transformResponse(request, successResponse, isAuthEndpoint);
  } catch (error) {
    console.error('API PUT Error:', error);
    const errorResponse = Response.json({ error: 'Internal server error' }, { status: 500 });
    return AuthBridge.transformResponse(request, errorResponse, false);
  }
}

export async function DELETE(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const path = url.pathname;
    const isAuthEndpoint = path.startsWith('/api/auth/');
    
    // Always enrich headers with session data
    const headers = await AuthBridge.enrichRequestHeaders(request);
    
    const result = await API.request({
      method: 'DELETE',
      path: path,
      headers: headers
    });
    
    if ('error' in result) {
      const errorResponse = Response.json({ error: result.error }, { status: 500 });
      return AuthBridge.transformResponse(request, errorResponse, isAuthEndpoint);
    }
    
    const response = await API._waitForResponse({ request: result.request });
    const responseData = response.length > 0 ? response[0] : { error: 'No response received' };
    
    if ('error' in responseData) {
      const errorResponse = Response.json(responseData, { status: 500 });
      return AuthBridge.transformResponse(request, errorResponse, isAuthEndpoint);
    }
    
    // Type assertion since responseData structure is dynamic
    const apiResponse = responseData as any;
    const successResponse = Response.json(apiResponse.body || apiResponse, { status: apiResponse.status || 200 });
    return AuthBridge.transformResponse(request, successResponse, isAuthEndpoint);
  } catch (error) {
    console.error('API DELETE Error:', error);
    const errorResponse = Response.json({ error: 'Internal server error' }, { status: 500 });
    return AuthBridge.transformResponse(request, errorResponse, false);
  }
}
