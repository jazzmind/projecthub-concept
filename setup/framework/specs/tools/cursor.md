## Cursor tool compiler spec

- **purpose**: Compile repository context + `.concept` specs into actionable `.cursor/rules/*` so Cursor can autonomously scaffold, code, test, and refine using concept design.
- **principles**: Follow repo rules (concepts independent; actions only side-effects; queries pure). All emitted rules must be deterministic, small, and self‑describing.

### Inputs

- `specs/*.concept` (source of truth)
- `.cursor/rules/*` already present (foundations; do not overwrite unless flagged)
- Optional: `ref/` primitives; `syncs/` declarations for route inference

### Outputs (.cursor/rules)

- `00-foundations.mdc` (links to concept/state rules; do not duplicate repo rules)
- `10-project-bootstrap.mdc` (how Cursor should initialize a new project with selected stack)
- `20-concepts/CONCEPT.mdc` (one per spec; state/actions/queries rendered with guidance)
- `30-syncs.mdc` (how to write synchronizations in TS using engine)
- `40-evals-runbook.mdc` (how to run evals via Cursor tasks)
- `50-style-quality.mdc` (coding standards derived from repo rules)
- `99-compiler-contract.mdc` (idempotence, regeneration instructions)

All files include minimal frontmatter:

---
description: generated by CompilerConcept — safe to regenerate
alwaysApply: true
---

### Generation algorithm

1) Scan `specs/*.concept`
2) For each concept file, extract:
   - concept name
   - state (SSF blocks → render as readable bullets + table)
   - actions (list with input/output maps; explain contract that actions receive a single object and return a single object)
   - queries (list + guidance: must be pure; return arrays)
   - operational principle (render verbatim in a collapsible tip)
3) Emit `20-concepts/<Concept>.mdc` with sections: Purpose, State, Actions, Queries, Operational principle, “Scaffold task” prompt for Cursor to implement or validate.
4) Emit `30-syncs.mdc` with:
   - engine import snippet, `actions(...)` helper, variable binding pattern
   - stepwise prompts for Cursor to create per‑route syncs from API concept patterns
5) Emit `10-project-bootstrap.mdc` with:
   - ask user for tool+stack confirmation (Cursor + selected stack)
   - task list: initialize repo, install deps, set up engine, scaffold concepts, scaffold syncs, run dev, open UI
6) Emit `40-evals-runbook.mdc` describing how Cursor should:
   - iterate `evals/*` projects
   - build each with the selected stack
   - compare against expected outputs
   - self‑refine rules and retry up to N attempts
7) Emit `50-style-quality.mdc` summarizing code style and logging rules from repo
8) Emit `99-compiler-contract.mdc` documenting regeneration and non‑destructive merges

### File structure to generate

- `.cursor/rules/00-foundations.mdc`
- `.cursor/rules/10-project-bootstrap.mdc`
- `.cursor/rules/20-concepts/<Concept>.mdc` (N files)
- `.cursor/rules/30-syncs.mdc`
- `.cursor/rules/40-evals-runbook.mdc`
- `.cursor/rules/50-style-quality.mdc`
- `.cursor/rules/99-compiler-contract.mdc`

### Install instructions

- Place files under project root `.cursor/rules`. Preserve existing bespoke rules; on conflict, append with a “Generated by CompilerConcept” section.

### Validation (Cursor tasks)

- Task: “Bootstrap project” using `10-project-bootstrap.mdc` checklists
- Task: “Regenerate concepts” from `20-concepts/*` and verify type‑shapes
- Task: “Write syncs” from `30-syncs.mdc` and ensure flows log correctly
- Task: “Run evals” from `40-evals-runbook.mdc`; adjust rules if mismatches

### Notes

- Deterministic: same inputs → identical rule files
- Small: prefer links to repo rules instead of copy‑pasting
- Self‑healing: eval runbook allows Cursor to PR changes to generated rules if repeated mismatches occur

