---
description: when creating/implementing concepts
alwaysApply: false
---
# Concept Implementation Rules

## TypeScript Implementation Standards

### Class Structure
- Each concept is implemented as a single TypeScript class: `${ConceptName}Concept`
- Place each concept in its own file: `concepts/${conceptName}.ts`
- Use Prisma with PostgreSQL for state persistence
- Each concept gets its own database table via Prisma schema

### Action Implementation
```typescript
// Action signature pattern
async actionName(input: { key: Type }): Promise<{ result: Type } | { error: string }> {
    // Implementation that either succeeds or returns error
}
```

### Query Implementation
```typescript
// Query signature pattern - must start with _
async _queryName(input: { key: Type }): Promise<Array<{ result: Type }>> {
    // Pure function that returns array of results
    // No side effects allowed
}
```

### Database Configuration
- Use environment variables for all Prisma/PostgreSQL configuration
- Share a single database between concepts but separate tables
- Use Prisma's auto-generated IDs for concept entity IDs
- Follow SSF (Simple State Form) translation rules for schema mapping

### Error Handling
- Return `{ error: string }` objects instead of throwing exceptions
- Validate inputs and return descriptive error messages
- Handle Prisma/PostgreSQL connection errors gracefully

### State Management
- Initialize Prisma client in constructor
- Use proper indexes for query performance
- Implement proper cleanup in concept lifecycle

## Dependencies
- Use Deno runtime for simplified imports
- Prefer generic module names without version numbers
- Import from `engine/mod.ts` for synchronization primitives

## Reference Implementation
See [Concept Implementation Guide](rules/docs/concept-implementation.md) for detailed patterns and examples.# Concept Implementation Rules

## TypeScript Implementation Standards

### Class Structure
- Each concept is implemented as a single TypeScript class: `${ConceptName}Concept`
- Place each concept in its own file: `concepts/${conceptName}.ts`
- Use Prisma with PostgreSQL for state persistence
- Each concept gets its own database table via Prisma schema

### Action Implementation
```typescript
// Action signature pattern
async actionName(input: { key: Type }): Promise<{ result: Type } | { error: string }> {
    // Implementation that either succeeds or returns error
}
```

### Query Implementation
```typescript
// Query signature pattern - must start with _
async _queryName(input: { key: Type }): Promise<Array<{ result: Type }>> {
    // Pure function that returns array of results
    // No side effects allowed
}
```

### Database Configuration
- Use environment variables for all Prisma/PostgreSQL configuration
- Share a single database between concepts but separate tables
- Use Prisma's auto-generated IDs for concept entity IDs
- Follow SSF (Simple State Form) translation rules for schema mapping

### Error Handling
- Return `{ error: string }` objects instead of throwing exceptions
- Validate inputs and return descriptive error messages
- Handle Prisma/PostgreSQL connection errors gracefully

### State Management
- Initialize Prisma client in constructor
- Use proper indexes for query performance
- Implement proper cleanup in concept lifecycle

## Dependencies
- Use Deno runtime for simplified imports
- Prefer generic module names without version numbers
- Import from `engine/mod.ts` for synchronization primitives

## Reference Implementation
See [Concept Implementation Guide](rules/docs/concept-implementation.md) for detailed patterns and examples.